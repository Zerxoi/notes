# 文件

## 数据库文件

### 配置参数文件

当MySQL实例启动时，数据库会先去读一个配置参数文件，用来寻找数据库的各种文件所在位置以及指定某些初始化参数，这些参数通常定义了某种内存结构有多大等。

在默认情况下，MySQL实例会按照一定的顺序在指定的位置进行读取，用户只需通过命令`mysql--help|grep my.cnf`来寻找即可。

数据库参数可以看成一个键/值（key/value）对。

- 可以通过命令`SHOW VARIABLES`查看数据库中的所有参数，也可以通过`LIKE`来过滤参数名。**(推荐)**
- 从MySQL 5.1版本开始，还可以通过`information_schema`架构下的`GLOBAL_VARIABLES`视图来进行查找。

#### 参数类型

MySQL数据库中的参数可以分为两类：

- 动态（dynamic）参数
- 静态（static）参数

动态参数意味着可以在MySQL实例运行中进行更改，静态参数说明在整个实例生命周期内都不得进行更改，就好像是只读（read only）的。可以通过SET命令对动态的参数值进行修改，SET的语法如下：

```sql
SET
|[global|session]system_var_name=expr
|[@@global.|@@session.|@@]system_var_name=expr
```

这里可以看到global和session关键字，它们表明该参数的修改是基于当前会话还是整个实例的生命周期。有些动态参数只能在会话中进行修改，如autocommit；而有些参数修改完后，在整个实例生命周期中都会生效，如binlog_cache_size；而有些参数既可以在会话中又可以在整个实例的生命周期内生效，如read_buffer_size。

### 日志文件

日志文件记录了影响MySQL数据库的各种类型活动。

#### 错误日志

错误日志文件对MySQL的启动、运行、关闭过程进行了记录。MySQL DBA在遇到问题时应该首先查看该文件以便定位问题。该文件不仅记录了所有的错误信息，也记录一些警告信息或正确的信息。用户可以通过命令`SHOW VARIABLES LIKE'log_error'`来定位该文件。

#### 慢查询日志

慢查询日志（slow log）可帮助DBA定位可能存在问题的SQL语句，从而进行SQL语句层面的优化。

通过参数`long_query_time`可以在MySQL启动时设一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询日志文件中。DBA每天或每过一段时间对其进行检查，确认是否有SQL语句需要进行优化。参数`long_query_time`默认值为10，代表10秒。

在默认情况下，MySQL数据库并不启动慢查询日志，用户需要手工将`log_slow_queries`参数设为`ON`。

MySQL 5.6.5版本开始新增了一个参数`log_throttle_queries_not_using_indexes`，用来表示每分钟允许记录到slow log的且未使用索引的SQL语句次数。该值默认为0，表示没有限制。

然而随着MySQL数据库服务器运行时间的增加，可能会有越来越多的SQL查询被记录到了慢查询日志文件中，此时要分析该文件就显得不是那么简单和直观的了。而这时MySQL数据库提供的`mysqldumpslow`命令。

MySQL 5.1开始可以将慢查询的日志记录放入一张表中，这使得用户的查询更加方便和直观。参数`log_output`指定了慢查询输出的格式，默认为`FILE`，可以将它设为`TABLE`，然后就可以查询`mysql`架构下的`slow_log`表了。参数`log_output`是动态的，并且是全局的，因此用户可以在线进行修改。

InnoSQL版本加强了对于SQL语句的捕获方式。在原版MySQL的基础上在slow log中增加了对于**逻辑读取（logical reads）**和**物理读取（physical reads）**的统计。逻辑读取中包含该语句从内存数据缓冲区中访问的页数和从物理磁盘读取的页数。而物理读取表示那些没有驻留在内存缓冲区中需要从磁盘读取的数据页。可以根据逻辑读与物理读的比例来决定是否对SQL语句进行优化。

用户可以通过额外的参数`long_query_io`将超过指定逻辑IO次数的SQL语句记录到slow log中。该值默认为100，即表示对于逻辑读取次数大于100的SQL语句，记录到slow log中。而为了兼容原MySQL数据库的运行方式，还添加了参数`slow_query_type`，用来表示启用slow log的方式，可选值为：

- 0表示不将SQL语句记录到slow log
- 1表示根据运行时间将SQL语句记录到slow log
- 2表示根据逻辑IO次数将SQL语句记录到slow log
- 3表示根据运行时间及逻辑IO次数将SQL语句记录到slow log

#### 查询日志

查询日志记录了所有对MySQL数据库请求的信息，无论这些请求是否得到了正确的执行。

- 默认文件名为：`主机名.log`。
- 对于未能正确执行的SQL语句，查询日志也会进行记录。
- 从MySQL 5.1开始，通过`log_output`参数可以将查询日志的记录放入`mysql`架构下的`general_log`表中。

#### 二进制日志

二进制日志（binary log）记录了对MySQL数据库执行更改的所有操作，即使这些修改操作可能并未生效（0 Changed）。

二进制日志主要有以下几种作用：

- **恢复（recovery）**：某些数据的恢复需要二进制日志，例如，在一个数据库全备文件恢复后，用户可以通过二进制日志进行point-in-time的恢复。
- **复制（replication）**：其原理与恢复类似，通过复制和执行二进制日志使一台远程的MySQL数据库（一般称为slave或standby）与一台MySQL数据库（一般称为master或primary）进行实时同步。
- **审计（audit）**：用户可以通过二进制日志中的信息来进行审计，判断是否有对数据库进行注入的攻击。

二进制日志文件在默认情况下并没有启动，需要手动指定参数来启动。通过配置参数`log-bin[=name]`可以启动二进制日志。如果不指定`name`，则默认二进制日志文件名为主机名，后缀名为二进制日志的序列号，所在路径为数据库所在目录（`datadir`参数)。

以下配置文件的参数影响着二进制日志记录的信息和行为：

- **max_binlog_size**

    参数`max_binlog_size`指定了单个二进制日志文件的最大值，如果超过该值，则产生新的二进制日志文件，后缀名+1，并记录到.index文件。

- **binlog_cache_size**

    当使用事务的表存储引擎（如InnoDB存储引擎）时，所有未提交（uncommitted）的二进制日志会被记录到一个缓存中去，等该事务提交（committed）时直接将缓冲中的二进制日志写入二进制日志文件，而该缓冲的大小由`binlog_cache_size`决定，默认大小为32K。

    `binlog_cache_size`是基于会话（session）的，也就是说，当一个线程开始一个事务时，MySQL会自动分配一个大小为`binlog_cache_size`的缓存，因此该值的设置需要相当小心，不能设置过大。当一个事务的记录大于设定的`binlog_cache_size`时，MySQL会把缓冲中的日志写入一个*临时文件*中，因此该值又不能设得太小。

    通过`show global status like'binlog_cache%'`命令查看`binlog_cache_use`、`binlog_cache_disk_use`的状态，可以判断当前`binlog_cache_size`的设置是否合适。其中，`binlog_cache_use`记录了使用缓冲写二进制日志的次数，`binlog_cache_disk_use`记录了使用*临时文件*写二进制日志的次数。

- **sync_binlog**

    在默认情况下，二进制日志并不是在每次写的时候同步到磁盘（用户可以理解为缓冲写）。因此，当数据库所在操作系统发生宕机时，可能会有最后一部分数据没有写入二进制日志文件中，这会给恢复和复制带来问题。参数`sync_binlog=[N]`表示每写缓冲多少次就同步到磁盘。

    `sync_binlog`的默认值为`0`，表示MySQL不控制binlog的刷新，由文件系统自己控制它的缓存的刷新。这时候的性能是最好的，但是风险也是最大的。因为一旦系统Crash，在binlog_cache中的所有binlog信息都会被丢失。

    如果将N设为1，即`sync_binlog=1`表示采用同步写磁盘的方式来写二进制日志，这时写操作不使用操作系统的缓冲来写二进制日志。但是，即使将`sync_binlog`设为1，还是会有一种情况导致问题的发生。当使用InnoDB存储引擎时，在一个事务发出COMMIT动作之前，由于`sync_binlog`为1，因此会将二进制日志立即写入磁盘。如果这时已经写入了二进制日志，但是提交还没有发生，并且此时发生了宕机，那么在MySQL数据库下次启动时，由于COMMIT操作并没有发生，这个事务会被回滚掉。但是二进制日志已经记录了该事务信息，不能被回滚。**这个问题可以通过将参数`innodb_support_xa`设为1来解决，虽然`innodb_support_xa`与XA事务有关，但它同时也确保了二进制日志和InnoDB存储引擎数据文件的同步。**

- **binlog-do-db** 和 **binlog-ignore-db**

参数**binlog-do-db**和**binlog-ignore-db**表示需要写入或忽略写入哪些库的日志。默认为空，表示需要同步所有库的日志到二进制日志。

- **log-slave-update**

    如果当前数据库是复制中的slave角色，则它不会将从master取得并执行的二进制日志写入自己的二进制日志文件中去。如果需要写入，要设置`log-slave-update`。如果需要搭建`master=＞*slave=＞slave`架构的复制，则必须设置该参数。

- **binlog_format**

    `binlog_format`参数十分重要，它影响了记录二进制日志的格式。

    在MySQL 5.1版本之前，没有这个参数。所有二进制文件的格式都是基于SQL语句（STATEMENT）级别的。如果使用二进制日志级别为STATEMENT级别会有如下问题：

  - 对于复制是有一定要求的。如在主服务器运行`rand`、`uuid`等函数，又或者使用触发器等操作，这些都可能会导致主从服务器上表中数据的**不一致**（not sync）
  - InnoDB存储引擎的默认事务隔离级别是`REPEATABLE READ`。这其实也是因为二进制日志文件格式的关系，如果使用`READ COMMITTED`的事务隔离级别，会出现类似丢失更新的现象，从而出现主从数据库上的数据不一致。

    MySQL 5.1开始引入了binlog_format参数，该参数可设的值有STATEMENT、ROW和MIXED。

    1. `STATEMENT`格式和之前的MySQL版本一样，二进制日志文件记录的是日志的逻辑SQL语句。
    2. 在`ROW`格式下，二进制日志记录的不再是简单的SQL语句了，而是记录表的行更改情况。对上述提及的`STATEMENT`格式下复制的问题予以解决。从MySQL 5.1版本开始，如果设置了`binlog_format`为`ROW`，可以将InnoDB的事务隔离基本设为`READ COMMITTED`，以获得更好的并发性。
    3. 在`MIXED`格式下，MySQL默认采用`STATEMENT`格式进行二进制日志文件的记录，但是在一些情况下会使用`ROW`格式，可能的情况有：

        - 表的存储引擎为NDB，这时对表的DML操作都会以ROW格式记录。
        - 使用了`UUID()`、`USER()`、`CURRENT_USER()`、`FOUND_ROWS()`、`ROW_COUNT()`等不确定函数。
        - 使用了`INSERT DELAY`语句。
        - 使用了用户定义函数（UDF）。
        - 使用了临时表（temporary table）。

    `binlog_format`是动态参数，因此可以在数据库运行环境下进行更改。在通常情况下，我们将参数`binlog_format`设置为`ROW`，这可以为数据库的恢复和复制带来更好的可靠性。但是不能忽略的一点是，这会带来二进制文件大小的增加，有些语句下的`ROW`格式可能需要更大的容量。而由于复制是采用传输二进制日志方式实现的，因此复制的网络开销也有所增加。

    二进制日志文件的文件格式为二进制，不能像错误日志文件、慢查询日志文件那样直接查看。要查看二进制日志文件的内容，必须通过MySQL提供的工具`mysqlbinlog`来查看看执行的SQL语句。

#### 套接字文件

在UNIX系统下本地连接MySQL可以采用UNIX域套接字方式，这种方式需要一个套接字（socket）文件。套接字文件可由参数socket控制。一般在`/tmp`目录下，名为`mysql.sock`。

#### pid文件

当MySQL实例启动时，会将自己的进程ID写入一个文件中——该文件即为**pid文件**。该文件可由参数`pid_file`控制，默认位于数据库目录下，文件名为**主机名.pid**。

#### 表结构定义文件

因为MySQL插件式存储引擎的体系结构的关系，MySQL数据的存储是根据表进行的，每个表都会有与之对应的文件。但不论表采用何种存储引擎，MySQL都有一个以`frm`为后缀名的文件，这个文件记录了该表的**表结构定义**。

## InnoDB存储引擎文件

之前介绍的文件都是MySQL数据库本身的文件，和存储引擎无关。除了这些文件外，每个表存储引擎还有其自己独有的文件。

### 表空间文件

InnoDB采用将存储的数据按表空间（tablespace）进行存放的设计。

默认情况下InnoDB存储引擎有一个**共享表空间**`ibdata1`，即所有数据都放在这个表空间内。用户可以通过参数`innodb_data_file_path`对其进行设置，格式如下：

```text
innodb_data_file_path=datafle_spec1[;datafle_spec2]...
```

若设置了参数`innodb_file_per_table`，则用户可以将每个基于InnoDB存储引擎的表产生一个**独立表空间**。独立表空间的命名规则为：`表名.ibd`。其对应的存储文件都放在`innodb_data_home_dir`指定的目录下。每张表的表空间内存放的只是数据、索引和插入缓冲，其它的数据，如撤销（Undo）信息、系统事务信息、二次写缓冲（double write buffer）等还是存放在原来的共享表空间内。

### 重做日志文件

在默认情况下，在InnoDB存储引擎的数据目录下会有两个名为`ib_logfile0`和`ib_logfile1`的文件 —— **重做日志文件（redo log file）**。

当实例或介质失败（media failure）时，重做日志文件就能派上用场。例如，数据库由于所在主机掉电导致实例失败，InnoDB存储引擎会使用重做日志恢复到掉电前的时刻，以此来保证数据的完整性。

#### 重做日志文件配置

每个InnoDB存储引擎至少有1个**重做日志文件组（group）**，每个文件组下至少有2个**重做日志文件**，如默认的`ib_logfile0`和`ib_logfile1`。为了得到更高的可靠性，用户可以设置多个的**镜像日志组（mirrored log groups）**，将不同的文件组放在不同的磁盘上，以此提高重做日志的高可用性。在日志组中每个重做日志文件的大小一致，并以循环写入的方式运行。

![重做日志文件组](imgs/%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%BB%84.png)

下列参数影响着重做日志文件的属性：

- **innodb_log_file_size**

参数`innodb_log_file_size`指定每个重做日志文件的大小。

- **innodb_log_files_in_group**

参数`innodb_log_files_in_group`指定了日志文件组中重做日志文件的数量，默认为2。

- **innodb_mirrored_log_groups**

参数`innodb_mirrored_log_groups`指定了日志镜像文件组的数量，默认为1，表示只有一个日志文件组，没有镜像。若磁盘本身已经做了高可用的方案，如磁盘阵列，那么可以不开启重做日志镜像的功能。

- **innodb_log_group_home_dir**

参数`innodb_log_group_home_dir`指定了日志文件组所在路径，默认为`./`，表示在MySQL数据库的数据目录下。

重做日志文件的大小设置对于InnoDB存储引擎的性能有着非常大的影响。

- 重做日志文件不能设置得太大，如果设置得很大，在恢复时可能需要很长的时间；
- 重做日志文件不能设置得太小了，否则可能导致一个事务的日志需要多次切换重做日志文件。
- 重做日志文件太小会导致频繁地发生async checkpoint，导致性能的抖动。

#### 重做日志文件与二进制文件

|重做日志文件|二进制文件|
|-------|----------|
|重做日志只记录有关该存储引擎本身的事务日志|二进制日志会记录所有与MySQL数据库有关的日志记录，包括InnoDB、MyISAM、Heap等其他存储引擎的日志|
|重做日志文件记录的是关于每个页（Page）的更改的物理情况|无论二进制日志文件记录的格式设为STATEMENT还是ROW，又或者是MIXED，其记录的都是关于一个事务的具体操作内容，即该日志是逻辑日志|
|在事务进行的过程中，却不断有重做日志条目（redo entry）被写入到重做日志文件中|二进制日志文件仅在事务提交前进行提交，即只写磁盘一次，不论这时该事务多大|

#### 重做日志格式

在InnoDB存储引擎中，对于各种不同的操作有着不同的重做日志格式。到InnoDB 1.2.x版本为止，总共定义了51种重做日志类型。虽然各种重做日志的类型不同，但是它们有着基本的格式：

![重做日志条目结构.png](imgs/%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%E6%9D%A1%E7%9B%AE%E7%BB%93%E6%9E%84.png)

- **redo_log_type**占用1字节，表示重做日志的类型
- **space**表示表空间的ID，但采用压缩的方式，因此占用的空间可能小于4字节
- **page_no**表示页的偏移量，同样采用压缩的方式
- **redo_log_body**表示每个重做日志的数据部分，恢复时需要调用相应的函数进行解析

#### 重做日志文件的写入

写入重做日志文件的操作不是直接写，而是先写入一个**重做日志缓冲（redo log buffer）**中，然后按照一定的条件顺序地写入日志文件。

![重做日志写入过程](imgs/%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%E5%86%99%E5%85%A5%E8%BF%87%E7%A8%8B.png)

从重做日志缓冲往磁盘写入时，是按512个字节，也就是一个扇区的大小进行写入。因为扇区是写入的最小单位，因此可以保证写入必定是成功的。因此在重做日志的写入过程中**不需要有doublewrite**。

日志缓冲写入磁盘：

- **主线程**每秒会将重做日志缓冲刷新至磁盘的重做日志文件中，不论事务是否已经提交
- 事务提交时刷新，由`innodb_flush_log_at_trx_commit`参数控制
- 重做日志缓冲池剩余空间小于1/2时刷新

参数`innodb_flush_log_at_trx_commit`的有效值有0、1、2。

- 0代表当提交事务时，并不将事务的重做日志写入磁盘上的日志文件，而是等待主线程每秒的刷新。
- 1表示在执行commit时将重做日志缓冲同步写到磁盘，即伴有fsync的调用。
- 2表示将重做日志异步写到磁盘，即写到文件系统的缓存中。因此不能完全保证在执行commit时肯定会写入重做日志文件，只是有这个动作发生。

因此为了保证事务的ACID中的持久性，必须将`innodb_flush_log_at_trx_commit`设置为1，也就是每当有事务提交时，就必须确保事务都已经写入重做日志文件。那么当数据库因为意外发生宕机时，可以通过重做日志文件恢复，并保证可以恢复已经提交的事务。而将重做日志文件设置为0或2，都有可能发生恢复时部分事务的丢失。不同之处在于，设置为2时，当MySQL数据库发生宕机而操作系统及服务器并没有发生宕机时，由于此时未写入磁盘的事务日志保存在文件系统缓存中，当恢复时同样能保证数据不丢失。

# 事务

事务可由一条或者多条SQL语句组成。事务是访问并更新数据库中各种数据项的一个程序执行单元。在事务中的操作，要么都做修改，要么都不做。

## 事务的特性

理论上说，事务有着极其严格的定义，它必须同时满足四个特性，即通常所说的*事务的ACID特性*。值得注意的是，虽然理论上定义了严格的事务要求，但是数据库厂商出于各种目的，并没有严格去满足事务的ACID标准。虽然在大多数的情况下，这并不会导致严重的结果，甚至可能还会带来性能的提升，但是用户首先需要知道严谨的事务标准，并在实际的生产应用中避免可能存在的潜在问题。对于InnoDB存储引擎而言，其默认的事务隔离级别为 `READ REPEATABLE`，完全遵循和满足事务的ACID特性。

1. **原子性（A，Atomicity）** 指整个数据库事务是*不可分割的工作单位*。只有使事务中所有的数据库操作都执行成功，才算整个事务成功。事务中任何一个SQL语句执行失败，已经执行成功的SQL语句也必须撤销，数据库状态应该退回到执行事务前的状态。
2. **一致性（C，Consistency）** 指事务将数据库*从一种状态转变为下一种一致的状态*。在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。
3. **一致性（C，Consistency）** 要求*每个读写事务的对象对其他事务的操作对象能相互分离*，即该事务提交前对其他事务都不可见，通常这使用锁来实现。当前数据库系统中都提供了一种粒度锁（granular lock）的策略，允许事务仅锁住一个实体对象的子集，以此来提高事务之间的并发度。
4. **持久性（D，Durability）** 指的是*事务一旦提交，其结果就是永久性的*。即使发生宕机等故障，数据库也能将数据恢复。

## 事务的分类

从事务理论的角度来说，可以把事务分为以下几种类型：

1. **扁平事务（Flat Transactions）**

    在扁平事务中，所有操作都处于*同一层次*，其由 `BEGIN WORK` 开始，由 `COMMIT WORK` 或 `ROLLBACK WORK` 结束，其间的*操作是原子的，要么都执行，要么都回滚*。扁平事务是事务类型中最简单的一种，在实际生产环境中使用最为频繁。

    ![扁平事务的三种情况](imgs/%E6%89%81%E5%B9%B3%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5.png)

    扁平事务的**主要限制**是*不能提交或者回滚事务的某一部分，或分几个步骤提交*。
2. **带有保存点的扁平事务（Flat Transactions with Savepoints）**

    带有保存点的扁平事务，除了支持扁平事务支持的操作外，*允许在事务执行过程中回滚到同一事务中较早的一个状态（保存点）*。这是因为某些事务可能在执行过程中出现的错误并不会导致所有的操作都无效，放弃整个事务不合乎要求，开销也太大。**保存点（Savepoint）**用来通知系统应该记住事务当前的状态，以便当之后发生错误时，事务能回到保存点当时的状态。

    对于扁平的事务来说，其隐式地设置了一个保存点。然而在整个事务中，只有这一个保存点，因此，回滚只能回滚到事务开始时的状态。保存点用 `SAVE WORK` 函数来建立，通知系统记录当前的处理状态。当出现问题时，保存点能用作内部的重启动点，根据应用逻辑，决定是回到最近一个保存点还是其他更早的保存点。

    ![在事务中使用保存点](imgs/%E5%9C%A8%E4%BA%8B%E5%8A%A1%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BF%9D%E5%AD%98%E7%82%B9.png)
3. **链事务（Chained Transactions）**

    链事务可视为保存点模式的一种变种。带有保存点的扁平事务，当发生系统崩溃时，所有的保存点都将消失，因为其保存点是易失的（`volatile`），而非持久的（`persistent`）。这意味着当进行恢复时，事务需要从开始处重新执行，而不能从最近的一个保存点继续执行。

    链事务的思想是：*在提交一个事务时，释放不需要的数据对象，将必要的处理上下文隐式地传给下一个要开始的事务*。注意，提交事务操作和开始下一个事务操作将合并为一个原子操作。这意味着下一个事务将看到上一个事务的结果，就好像在一个事务中进行的一样。

    ![链事务](imgs/%E9%93%BE%E4%BA%8B%E5%8A%A1.png)

    链事务与带有保存点的扁平事务不同：

    - 带有保存点的扁平事务能回滚到任意正确的保存点；而链事务中的回滚仅限于当前事务，即只能恢复到最近一个的保存点。
    - 带有保存点的扁平事务在创建保存点时，不影响迄今为止所持有的锁；而链事务在执行 `COMMIT` 后即释放了当前事务所持有的锁。
4. **嵌套事务（Nested Transactions）**

    嵌套事务是一个**层次结构框架**。由一个**顶层事务（top-level transaction）**控制着各个层次的事务。顶层事务之下嵌套的事务被称为**子事务（subtransaction）**，其控制每一个局部的变换。

    ![嵌套事务的层次结构](imgs/%E5%B5%8C%E5%A5%97%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png)

    Moss对嵌套事务的定义：

    1. 嵌套事务是由若干事务组成的一棵树，子树既可以是嵌套事务，也可以是扁平事务。
    2. 处在叶节点的事务是扁平事务。但是每个子事务从根到叶节点的距离可以是不同的。
    3. 位于根节点的事务称为顶层事务，其他事务称为子事务。事务的前驱称为父事务（parent），事务的后继称为儿子事务（child）。
    4. 子事务既可以提交也可以回滚。但是它的提交操作并不马上生效，除非其父事务已经提交。因此可以推论出，任何子事物都在顶层事务提交后才真正的提交。
    5. 树中的任意一个事务的回滚会引起它的所有子事务一同回滚，故子事务仅保留A、C、I特性，不具有D的特性。

    在Moss的理论中，实际的工作是交由叶子节点来完成的，即只有叶子节点的事务才能访问数据库、发送消息、获取其他类型的资源。而高层的事务仅负责逻辑控制，决定何时调用相关的子事务。即使一个系统不支持嵌套事务，用户也可以通过保存点技术来模拟嵌套事务，如下图所示：

    ![用保存点技术来模拟嵌套事务](imgs/%E7%94%A8%E4%BF%9D%E5%AD%98%E7%82%B9%E6%8A%80%E6%9C%AF%E6%9D%A5%E6%A8%A1%E6%8B%9F%E5%B5%8C%E5%A5%97%E4%BA%8B%E5%8A%A1.png)

    在恢复时采用保存点技术比嵌套查询有更大的**灵活性**，因此保存点技术可以回滚到指定的保存点；而在嵌套查询的层次结构中，这是不被允许的。

    但是用保存点技术来模拟嵌套事务在**锁**的持有方面还是与嵌套查询有些区别。当通过保存点技术来模拟嵌套事务时，用户无法选择哪些锁需要被子事务继承，哪些需要被父事务保留。这就是说，无论有多少个保存点，所有被锁住的对象都可以被得到和访问。而在嵌套查询中，不同的子事务在数据库对象上持有的锁是不同的。例如有一个父事务P1，其持有对象X和Y的排他锁，现在要开始一个调用子事务P11，那么父事务P1可以不传递锁，也可以传递所有的锁，也可以只传递一个排他锁。如果子事务P11中还要持有对象Z的排他锁，那么通过反向继承（counter-inherited），父事务P1将持有3个对象X、Y、Z的排他锁。如果这时又再次调用了一个子事务P12，那么它可以选择传递那里已经持有的锁。

    然而，如果系统支持在嵌套事务中**并行**地执行各个子事务，在这种情况下，采用保存点的扁平事务来模拟嵌套事务就不切实际了。这从另一个方面反映出，想要实现事务间的并行性，需要真正支持的嵌套事务。

5. **分布式事务（Distributed Transactions）**

    分布式事务通常是一个*在分布式环境下运行的扁平事务*，因此需要根据数据所在位置访问网络中的不同节点。

对于InnoDB存储引擎来说，其支持**扁平事务**、**带有保存点的事务**、**链事务**、**分布式事务**。对于嵌套事务，其并不原生支持，因此，对有并行事务需求的用户来说，MySQL数据库或InnoDB存储引擎就显得无能为力了。然而用户仍可以通过带有保存点的事务来模拟串行的嵌套事务。

## 事务的实现

原子性、一致性、持久性通过数据库的 `redo log` 和 `undo log` 来完成。`redo log` 称为重做日志，用来保证事务的**原子性**和**持久性**。`undo log` 用来保证事务的**原子性**和**一致性**。

`redo` 和 `undo` 的作用都可以视为是一种恢复操作，`redo` 恢复提交事务修改的**页**操作，而 `undo` 回滚**行记录**到某个特定版本。因此两者记录的内容不同，`redo`通常是**物理日志**，记录的是*页*的物理修改操作。`undo` 是**逻辑日志**，根据每*行记录*进行记录。

有关物理和逻辑日志的内容可以参考[此文章](https://spongecaptain.cool/post/database/logicalandphicallog/)。

- 物理日志中存储面向物理寻址（页）
- 逻辑日志中存储面向逻辑寻址（行记录）

### redo

重做日志用来实现事务的**持久性**。

重做日志由两部分组成：

1. 内存中的**重做日志缓冲（redo log buffer）**，其是易失的；
2. 文件系统中的**重做日志文件（redo log file）**，其是持久的。

InnoDB是事务的存储引擎，其通过 Force Log at Commit 机制实现事务的持久性，即当事务提交（COMMIT）时，必须先将该事务的所有日志写入到重做日志文件进行持久化，待事务的 COMMIT 操作完成才算完成。在InnoDB存储引擎中，事务的日志由两部分组成，即 `redo log` 和 `undo log`。`redo log`用来保证事务的**持久性**，`undo log` 用来帮助事务**回滚**及**MVCC**的功能。`redo log`基本上都是顺序写的，在数据库运行时不需要对`redo log`的文件进行读取操作。而`undo log`是需要进行随机读写的。换句话说，`undo log` 也需要持久化，因此也会产生 `redo log`。

---

#### 重做日志磁盘刷新策略

为了确保每次日志都写入重做日志文件，在每次将重做日志缓冲写入重做日志文件后，InnoDB存储引擎都需要调用一次 `fsync` 操作。由于重做日志文件打开并没有使用 `O_DIRECT` 选项，因此重做日志缓冲先写入文件系统缓存。为了确保重做日志写入磁盘，必须进行一次 `fsync` 操作。由于 `fsync` 的效率取决于磁盘的性能，因此磁盘的性能决定了事务提交的性能，也就是数据库的性能。

![重做日志磁盘刷新策略](imgs/%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%E5%88%B7%E6%96%B0%E7%A3%81%E7%9B%98%E7%AD%96%E7%95%A5.drawio.png)

InnoDB存储引擎允许用户手工设置非持久性的情况发生，以此提高数据库的性能。即当事务提交时，日志不写入重做日志文件，而是等待一个时间周期后再执行 `fsync` 操作。由于并非强制在事务提交时进行一次 `fsync` 操作，显然这可以显著提高数据库的性能。但是当数据库发生宕机时，由于部分日志未刷新到磁盘，因此会丢失最后一段时间的事务。

参数 `innodb_flush_log_at_trx_commit` 用来控制重做日志刷新到磁盘的策略。

- `1`：默认值，表示事务提交时必须调用一次 `fsync` 操作。
- `0`：表示事务提交时不进行写入重做日志操作，这个操作仅在 Master Thread 中完成，而在 Master Thread 中每 1 秒会进行一次重做日志文件的 `fsync` 操作。
- `2`：表示事务提交时将重做日志写入重做日志文件，但仅写入文件系统的缓存中，不进行 `fsync` 操作。在这个设置下，当 MySQL 数据库发生宕机而操作系统不发生宕机时，并不会导致事务的丢失。而当操作系统宕机时，重启数据库后会丢失未从文件系统缓存刷新到重做日志文件那部分事务。

用户可以通过设置参数 `innodb_flush_log_at_trx_commit` 为 `0` 或 `2` 来提高事务提交的性能，但是这种设置方法丧失了事务的 ACID 特性。

#### 重做日志与二进制日志

在MySQL数据库中还有一种**二进制日志（binlog）**，其用来进行 *POINT-IN-TIME（PIT） 的恢复* 及 *主从复制（Replication）* 环境的建立。从表面上看其和重做日志非常相似，都是记录了对于数据库操作的日志。然而，从本质上来看，两者有着非常大的不同。

- 产生的层级不同。重做日志是在**InnoDB存储引擎层**产生，而二进制日志是在**MySQL数据库层**产生的，并且二进制日志不仅仅针对于InnoDB存储引擎，MySQL数据库中的任何存储引擎对于数据库的更改都会产生二进制日志。
- 内容形式不同。MySQL数据库上层的二进制日志是一种**逻辑日志**，其记录的是对应的 *SQL语句*。而InnoDB存储引擎层面的重做日志是**物理日志**，其记录的是对于每个 *页的修改*。
- 写入磁盘的时间点不同。二进制日志只在事务**提交完成后进行一次写入**。而InnoDB存储引擎的重做日志在**事务进行中不断地被写入**，这表现为日志并不是随事务提交的顺序进行写入的。

---

#### 重做日志组

`log group` 为**重做日志组**，是一个逻辑上的概念，并没有一个实际存储的物理文件来表示 `log group` 信息。`log group` 由多个重做日志文件组成，每个 `log group` 中的日志文件大小是相同的，且在 InnoDB 1.2 版本之前，重做日志文件的总大小要小于 4 GB（不能等于4GB）。从 InnoDB 1.2 版本开始重做日志文件总大小的限制提高为了 512 GB。InnoSQL版本的InnoDB存储引擎在1.1版本就支持大于4GB的重做日志。

---

#### 重做日志文件

在InnoDB存储引擎中，**重做日志缓存（redo log buffer）**、**重做日志文件（redo log file）**都是以块的方式进行保存的，称之为**重做日志块（redo log block）**，每块的大小为 512 字节。重做日志文件中存储的就是之前在重做日志缓存中保存的重做日志块。

重做日志缓存根据一定的规则将内存中的重做日志块刷新到磁盘：

- 事务提交时
- 当 `log buffer` 中有一半的内存空间已经被使用时
- log checkpoint 时

对于 `log block` 的写入追加在 `redo log file` 的最后部分，当一个 `redo log file` 被写满时，会接着写入下一个 `redo log file`，其使用方式为 round-robin。

虽然 `log block` 总是在 `redo log file` 的最后部分进行写入，有的读者可能以为对 `redo log file` 的写入都是顺序的。其实不然，因为 `redo log file` 除了保存 `log buffer` 刷新到磁盘的 `log block`，还保存了一些其他的信息，这些信息一共占用 2 KB大小，即每个 `redo log file` 的前 2 KB的部分不保存 `log block` 的信息。对于 `log group` 中的第一个 `redo log file`，其前2KB的部分保存 4 个 512 字节大小的块，其中存放的内容如下表所示。

![redo log file前2KB部分的内容](imgs/redo%20log%20file%20%E5%89%8D2KB%E9%83%A8%E5%88%86%E7%9A%84%E5%86%85%E5%AE%B9.png)

需要特别注意的是，上述信息仅在每个 `log group` 的第一个 `redo log file` 中进行存储。`log group` 中的其余 `redo log file` 仅保留这些空间，但不保存上述信息。正因为保存了这些信息，就意味着**对 redo log file 的写入并不是完全顺序的**。因为其除了 `log block` 的写入操作，还需要更新前 2 KB部分的信息，这些信息对于 InnoDB 存储引擎的恢复操作来说非常关键和重要。故 `log group` 与 `redo log file` 之间的关系如下图所示。

![log group与redo log file之间的关系](imgs/log%20group%E4%B8%8Eredo%20log%20file%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png)

---

#### 重做日志块

在InnoDB存储引擎中，重做日志都是以512字节进行存储的。这意味着重做日志缓存、重做日志文件都是以块的方式进行保存的，称之为**重做日志块（redo log block）**，每块的大小为512字节。

若一个页中产生的重做日志数量大于512字节，那么需要分割为多个重做日志块进行存储。此外，由于重做日志块的大小和磁盘扇区大小一样，都是 512 字节，因此重做日志的写入可以保证**原子性**，不需要 doublewrite 技术。

重做日志块除了日志本身之外，还由日志块头（log block header）及日志块尾（log block tailer）两部分组成。重做日志头一共占用12字节，重做日志尾占用8字节。故每个重做日志块实际可以存储的大小为492字节（512-12-8）。

![重做日志块缓存的结构](imgs/%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%E5%9D%97%E7%BC%93%E5%AD%98%E7%9A%84%E7%BB%93%E6%9E%84.png)

上图显示了重做日志块缓存的结构。可以发现重做日志缓存由每个为512字节大小的日志块所组成。日志块由三部分组成，依次为**日志块头（log block header）**、**日志内容（log body）**、**日志块尾（log block tailer）**。

---

#### 重做日志格式

重做日志块中存放的是重做日志。不同的数据库操作会有对应的重做日志格式。此外，由于InnoDB存储引擎的存储管理是基于页的，故其重做日志格式也是基于页的。虽然有着不同的重做日志格式，但是它们有着通用的头部格式，如下图所示：

![重做日志格式](imgs/%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F.png)

通用的头部格式由以下3部分组成：

- `redo_log_type`：重做日志的类型。
- `space`：表空间的ID。
- `page_no`：页的偏移量。

之后redo log body的部分，根据重做日志类型的不同，会有不同的存储内容，例如，对于页上记录的插入和删除操作，分别对应如下图所示的格式：

![插入和删除的重做日志格式](imgs/%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E7%9A%84%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F.png)

---

#### LSN

LSN 是 Log Sequence Number 的缩写，其代表的是日志序列号。在 InnoDB 存储引擎中， LSN 占用 8 字节，并且单调递增。LSN 表示的含义有：

- 重做日志写入的总量
  - 例如当前重做日志的 LSN 为 1000，有一个事务 T1 写入了 `100` 字节的重做日志，那么 LSN 就变为了 `1100`，若又有事务 T2 写入了 `200` 字节的重做日志，那么 LSN 就变为了 `1300`。可见 LSN 记录的是重做日志的总量，其单位为字节。
- checkpoint的位置
- 页的版本
  - LSN不仅记录在重做日志中，还存在于每个页中。在每个页的头部，有一个值 `FIL_PAGE_LSN`，记录了该页的LSN。在页中，LSN表示该页最后刷新时LSN的大小。因为重做日志记录的是每个页的日志，因此页中的LSN用来判断页是否需要进行**恢复操作**。
  - 例如，页 P1 的 LSN 为 `10000`，而数据库启动时，InnoDB 检测到写入重做日志中的 LSN 为 `13000`，并且该事务已经提交，那么数据库需要进行恢复操作，将重做日志应用到 P1 页中。同样的，对于重做日志中 LSN 小于 P1 页的 LSN，不需要进行重做，因为 P1 页中的 LSN 表示页已经被刷新到该位置。

用户可以通过命令 `SHOW ENGINE INNODB STATUS` 查看 LSN 的情况。

---

#### 恢复

InnoDB存储引擎在启动时不管上次数据库运行时是否正常关闭，都会尝试进行恢复操作。

- 因为重做日志记录的是物理日志，因此恢复的速度比逻辑日志，如二进制日志，要快很多。
- InnoDB存储引擎自身也对恢复进行了一定程度的优化，如顺序读取及并行应用重做日志（多页并行进行恢复），这样可以进一步地提高数据库恢复的速度。

由于 checkpoint 表示已经刷新到磁盘页上的LSN，因此在恢复过程中仅需恢复 checkpoint 开始的日志部分。对于下图中的例子，当数据库在 checkpoint 的 `LSN` 为 `10000` 时发生宕机，恢复操作仅恢复LSN `10000` ~ `13000` 范围内的日志。

![恢复的例子](imgs/%E6%81%A2%E5%A4%8D%E7%9A%84%E4%BE%8B%E5%AD%90.png)

### undo

#### 基本概念

重做日志记录了事务的行为，可以很好地通过其对页进行“重做”操作。但是事务有时还需要进行**回滚操作**，这时就需要undo。因此在对数据库进行修改时，InnoDB存储引擎不但会产生redo，还会产生一定量的undo。这样如果用户执行的事务或语句由于某种原因失败了，又或者用户用一条ROLLBACK语句请求回滚，就可以利用这些undo信息将数据回滚到修改之前的样子。

除了回滚操作，undo的另一个作用是**MVCC**，即在InnoDB存储引擎中MVCC的实现是通过undo来完成。当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过undo读取之前的行版本信息，以此实现非锁定读取。

最后也是最为重要的一点是，**undo log会产生redo log**，也就是undo log的产生会伴随着redo log的产生，这是因为undo log也需要持久性的保护。

#### 为什么是逻辑日志？

redo存放在重做日志文件中，与redo不同，undo存放在数据库内部的一个特殊段（segment）中，这个段称为undo段（undo segment）。

用户通常对undo有这样的误解：undo用于将数据库物理地恢复到执行语句或事务之前的样子——但事实并非如此。undo是逻辑日志，因此只是将数据库逻辑地恢复到原来的样子。所有修改都被逻辑地取消了，但是数据结构和页本身在回滚之后可能大不相同。这是因为在多用户并发系统中，可能会有数十、数百甚至数千个并发事务。数据库的主要任务就是协调对数据记录的并发访问。比如，一个事务在修改当前一个页中某几条记录，同时还有别的事务在对同一个页中另几条记录进行修改。因此，不能将一个页回滚到事务开始的样子，因为这样会影响其他事务正在进行的工作。（不能根据页进行回滚，要根据行记录进行回滚）

#### undo 存储管理

InnoDB存储引擎对undo的管理同样采用段的方式。但是这个段和之前介绍的段有所不同。首先InnoDB存储引擎有rollback segment，每个回滚段种记录了1024个undo log segment，而在每个undo log segment段中进行undo页的申请。共享表空间偏移量为5的页（0，5）记录了所有rollback segment header所在的页，这个页的类型为 `FIL_PAGE_TYPE_SYS`。

需要特别注意的是，事务在undo log segment分配页并写入undo log的这个过程同样需要写入重做日志。当事务提交时，InnoDB存储引擎会做以下两件事情：

- 将undo log放入列表中，以供之后的purge操作
  - 事务提交后并不能马上删除undo log及undo log所在的页。这是因为可能还有其他事务需要通过undo log来得到行记录之前的版本。故事务提交时将undo log放入一个链表中，是否可以最终删除undo log及undo log所在页由purge线程来判断。
- 判断undo log所在的页是否可以重用，若可以分配给下个事务使用
  - 此外，若为每一个事务分配一个单独的undo页会非常浪费存储空间，特别是对于OLTP的应用类型。因为在事务提交时，可能并不能马上释放页。假设某应用的删除和更新操作的TPS（transaction per second）为1000，为每个事务分配一个undo页，那么一分钟就需要1000*60个页，大约需要的存储空间为1GB。若每秒的purge页的数量为20，这样的设计对磁盘空间有着相当高的要求。因此，在InnoDB存储引擎的设计中对undo页可以进行重用。具体来说，当事务提交时，首先将undo log放入链表中，然后判断undo页的使用空间是否小于3/4，若是则表示该undo页可以被重用，之后新的undo log记录在当前undo log的后面。由于存放undo log的列表是以记录进行组织的，而undo页可能存放着不同事务的undo log，因此purge操作需要涉及磁盘的离散读取操作，是一个比较缓慢的过程。

可以通过命令 `SHOW ENGINE INNODB STATUS` 来查看链表中 `undo log` 的数量。

#### undo log 格式

在InnoDB存储引擎中，undo log分为：

- insert undo log

  insert undo log是指在insert操作中产生的undo log。因为insert操作的记录，只对事务本身可见，对其他事务不可见（这是事务隔离性的要求），故该undo log可以在事务提交后直接删除。不需要进行purge操作。insert undo log的格式如下图所示。
  
  ![insert undo log的格式](imgs/insert%20undo%20log%E7%9A%84%E6%A0%BC%E5%BC%8F.png)
- update undo log

  update undo log记录的是对delete和update操作产生的undo log。该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。update undo log的结构如下图所示。

  ![update undo log格式](imgs/update%20undo%20log%E6%A0%BC%E5%BC%8F.png)

### purge

delete和update操作可能并不直接删除原有的数据。例如，对上一小节所产生的表t执行如下的SQL语句：

```sql
DELETE FROM t WHERE a=1;
```

表t上列a有聚集索引，列b上有辅助索引。对于上述的delete操作，通过前面关于undo log的介绍已经知道仅是将主键列等于1的记录delete flag设置为1，记录并没有被删除，即记录还是存在于B+树中。其次，对辅助索引上a等于1，b等于1的记录同样没有做任何处理，甚至没有产生undo log。**而真正删除这行记录的操作其实被“延时”了，最终在purge操作中完成**。

purge用于最终完成delete和update操作。这样设计是因为InnoDB存储引擎支持MVCC，所以记录不能在事务提交时立即进行处理。这时其他事物可能正在引用这行，故InnoDB存储引擎需要保存记录之前的版本。而是否可以删除该条记录通过purge来进行判断。若该行记录已不被任何其他事务引用，那么就可以进行真正的delete操作。可见，purge操作是清理之前的delete和update操作，将上述操作“最终”完成。而实际执行的操作为delete操作，清理之前行记录的版本。

---

在前一个小节中已经介绍过如果undo log所在页是**可重用的**，为了节省存储空间，InnoDB存储引擎的undo log设计是这样的：一个页上允许多个事务的undo log存在。虽然这不代表事务在全局过程中提交的顺序，但是后面的事务产生的undo log总在最后。此外，InnoDB存储引擎还有一个history列表，它根据事务提交的顺序，将undo log进行链接。如下面的一种情况：

在下图的例子中，history list表示按照事务提交的顺序将undo log进行组织。在InnoDB存储引擎的设计中，先提交的事务总在尾端。undo page存放了undo log，由于可以重用，因此一个undo page中可能存放了多个不同事务的undo log。trx5的灰色阴影表示该undo log还被其他事务引用。

在执行purge的过程中，InnoDB存储引擎首先从history list中找到第一个需要被清理的记录，这里为trx1，清理之后InnoDB存储引擎会在trx1的undo log所在的页中继续寻找是否存在可以被清理的记录，这里会找到事务trx3，接着找到trx5，但是发现trx5被其他事务所引用而不能清理，故去再次去history list中查找，发现这时最尾端的记录为trx2，接着找到trx2所在的页，然后依次再把事务trx6、trx4的记录进行清理。由于undo page2中所有的页都被清理了，因此该undo page可以被重用。

![undo log与history列表的关系](imgs/undo%20log%E4%B8%8Ehistory%E5%88%97%E8%A1%A8%E7%9A%84%E5%85%B3%E7%B3%BB.png)

InnoDB存储引擎这种先从history list中找undo log，然后再从undo page中找undo log的设计模式是为了避免大量的随机读取操作，从而提高purge的效率。

### group commit

若事务为非只读事务，则每次事务提交时需要进行一次 `fsync` 操作，以此保证重做日志都已经写入磁盘。当数据库发生宕机时，可以通过重做日志进行恢复。虽然固态硬盘的出现提高了磁盘的性能，然而磁盘的 `fsync` 性能是有限的。为了提高磁盘 `fsync` 的效率，当前数据库都提供了 group commit 的功能，即**一次fsync可以刷新确保多个事务日志被写入文件**。对于 InnoDB 存储引擎来说，事务提交时会进行两个阶段的操作：

1. 修改内存中事务对应的信息，并且将日志写入重做日志缓冲。
2. 调用fsync将确保日志都从重做日志缓冲写入磁盘。

步骤2相对步骤1是一个较慢的过程，这是因为存储引擎需要与磁盘打交道。但当有事务进行这个过程时，其他事务可以进行步骤1的操作，正在提交的事物完成提交操作后，再次进行步骤2时，可以将多个事务的重做日志通过一次 `fsync` 刷新到磁盘，这样就大大地减少了磁盘的压力，从而提高了数据库的整体性能。对于写入或更新较为频繁的操作，group commit的效果尤为明显。

## 事务控制语句

- `START TRANSACTION` | `BEGIN`：显式地开启一个事务。
  - 在存储过程中，MySQL 数据库的分析器会自动将 `BEGIN` 识别为存储过程开始和结束标识符 `BEGIN…END`，因此在存储过程中只能使用 `START TRANSACTION` 语句来开启一个事务。
- `COMMIT` | `COMMIT WORK`：显式地提交一个事务。
  - `COMMIT` 和 `COMMIT WORK` 的不同之处在于 `COMMIT WORK` 可以通过 `completion_type` 参数来控制事务结束后的行为：
    - `completion_type = 0`：`COMMIT WORK` 提交后不进行任何操作，等价于 `COMMIT`。
    - `completion_type = 1`：`COMMIT WORK` 提交后会自动开启一个相同隔离级别的事务，等价于 `COMMIT AND CHAIN`。
    - `completion_type = 1`：`COMMIT WORK` 提交后会自动断开与服务器的连接，等价于 `COMMIT AND RELEASE`。
  - 要想使用这个语句的最简形式，只需发出 `COMMIT`。也可以更详细一些，写为`COMMIT WORK`，不过这二者几乎是等价的。COMMIT会提交事务，并使得已对数据库做的所有修改成为永久性的。
- `ROLLBACK` | `ROLLBACK WORK`：显示地回滚一个事务。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改。
  - `ROLLBACK` 和 `ROLLBACK WORK` 与 `COMMIT` 和 `COMMIT WORK` 的工作一样，这里不再进行赘述。
  - `ROLLBACK TO SAVEPOINT` 中虽然有 `ROLLBACK`，但其并不是真正地结束一个事务，因此即使执行了 `ROLLBACK TO SAVEPOINT`，之后也需要显式地运行 `COMMIT` 或 `ROLLBACK` 命令。
- `SAVEPOINT identifier`：`SAVEPOINT` 允许在事务中创建一个保存点，一个事务中可以有多个 `SAVEPOINT`。
- `RELEASE SAVEPOINT identifier`：删除一个事务的保存点，当没有一个保存点执行这句语句时，会抛出一个异常。
- `ROLLBACK TO [SAVEPOINT] identifier`：这个语句与 `SAVEPOINT` 命令一起使用。可以把事务回滚到标记点，而不回滚在此标记点之前的任何工作。如果回滚到一个不存在的保存点，会抛出异常。
- `SET TRANSACTION`：这个语句用来设置事务的隔离级别。InnoDB存储引擎提供的事务隔离级别有：`READ UNCOMMITTED`、`READ COMMITTED`、`REPEATABLE READ`、`SERIALIZABLE`。

需要注意的是，事务中的一条语句失败并抛出异常时，并不会导致先前已经执行的语句自动回滚。所有的执行都会得到保留，必须由用户自己来决定是否对其进行提交或回滚的操作。

## 隐式提交的SQL语句

以下这些SQL语句会产生一个隐式的提交操作，即执行完这些语句后，会有一个隐式的COMMIT操作。

- DDL 语句：`ALTER DATABASE...UPGRADE DATA DIRECTORY NAME`，`ALTER EVENT`，`ALTER PROCEDURE`，`ALTER TABLE`，`ALTER VIEW`，`CREATE DATABASE`，`CREATE EVENT`，`CREATE INDEX`，`CREATE PROCEDURE`，`CREATE TABLE`，`CREATE TRIGGER`，`CREATE VIEW`，`DROP DATABASE`，`DROP EVENT`，`DROP INDEX`，`DROP PROCEDURE`，`DROP TABLE`，`DROP TRIGGER`，`DROP VIEW`，`RENAME TABLE`，`TRUNCATE TABLE`。
- 用来隐式地修改 MySQL 架构的操作：`CREATE USER`、`DROP USER`、`GRANT`、`RENAME USER`、`REVOKE`、`SET PASSWORD`。
- 管理语句：`ANALYZE TABLE`、`CACHE INDEX`、`CHECK TABLE`、`LOAD INDEX INTO CACHE`、`OPTIMIZE TABLE`、`REPAIR TABLE`。

另外需要注意的是，`TRUNCATE TABLE` 语句是 DDL，因此虽然和对整张表执行 `DELETE` 的结果是一样的，但它是不能被回滚的。

## 对事务操作的统计

由于 InnoDB 存储引擎是支持事务的，因此 InnoDB 存储引擎的应用需要在考虑每秒查询数（Queries Per Second，QPS）的同时，应该关注每秒事务处理的能力（Transaction Per Second，TPS）。

计算 TPS 的方法是 `(com_commit + com_rollback) / time`。但是利用这种方法进行计算的前提是：所有的事务必须都是显式提交的，如果存在隐式地提交和回滚（默认 `autocommit = 1` ），不会计算到 `com_commit` 和 `com_rollback` 变量中。

MySQL 通过 `SHOW GLOBAL STATUS LIKE 'com_commit'` 和 `SHOW GLOBAL STATUS LIKE 'com_commit'` 查看 com_commit 和 com_rollback 变量。

## 事务的隔离级别

SQL标准定义的四个隔离级别为：

- `READ UNCOMMITTED`
- `READ COMMITTED`
  - 在 `READ COMMITTED` 的事务隔离级别下，除了唯一性的约束检查及外键约束的检查需要 gap lock，InnoDB 存储引擎不会使用 gap lock 的锁算法。
  - 在MySQL 5.0版本以前，在不支持ROW格式的二进制日志时，可以将参数 `innodb_locks_unsafe_for_binlog` 设置为 `1` 可以在二进制日志为 `STATEMENT` 下使用 `READ COMMITTED` 的事务隔离级别会导致 `binlog` 与数据库数据不一致，进而引起主从不一致。
  - 在MySQL 5.1版本之后支持了 `ROW` 格式的二进制日志记录格式，避免了`READ COMMITTED`的事务隔离级别产生的数据不一致问题。
- `REPEATABLE READ`
  - 因为 InnoDB 存储引擎在 `REPEATABLE READ` 隔离级别下就可以达到 3° 的隔离，因此一般不在本地事务中使用 `SERIALIABLE` 的隔离级别。
- `SERIALIZABLE`
  - 在 `SERIALIABLE` 的事务隔离级别，InnoDB 存储引擎会对每个 `SELECT` 语句后自动加上 `LOCK IN SHARE MODE`，即为每个读取操作加一个共享锁。因此在这个事务隔离级别下，读占用了锁，对一致性的非锁定读不再予以支持。
  - `SERIALIABLE` 的事务隔离级别主要用于InnoDB存储引擎的分布式事务。

## 分布式事务

### MySQL 的分布式事务

InnoDB 存储引擎提供了对 XA 事务的支持，并通过 XA 事务来支持分布式事务的实现。

**分布式事务**指的是允许多个独立的事务资源（transactional resources）参与到一个全局的事务中。事务资源通常是关系型数据库系统，但也可以是其他类型的资源。全局事务要求在其中的所有参与的事务要么都提交，要么都回滚，这对于事务原有的 ACID 要求又有了提高。

另外，在使用分布式事务时，InnoDB存储引擎的事务隔离级别必须设置为 `SERIALIZABLE`。

XA事务由一个或多个**资源管理器（Resource Managers）**、一个**事务管理器（Transaction Manager）**以及一个**应用程序（Application Program）**组成。

- 资源管理器：提供访问事务资源的方法。通常一个数据库就是一个资源管理器。
- 事务管理器：协调参与全局事务中的各个事务。需要和参与全局事务的所有资源管理器进行通信。
- 应用程序：定义事务的边界，指定全局事务中的操作。

在MySQL数据库的分布式事务中，资源管理器就是MySQL数据库，事务管理器为连接MySQL服务器的客户端。下图显示了一个分布式事务的模型。

![分布式事务模型](imgs/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%9E%8B.png)

分布式事务使用**两段式提交（two-phase commit）**的方式。

- 第一阶段，所有参与全局事务的节点都开始准备（`PREPARE`），告诉事务管理器它们准备好提交了。
- 第二阶段，事务管理器告诉资源管理器执行 `ROLLBACK` 还是 `COMMIT`。如果任何一个节点显示不能提交，则所有的节点都被告知需要回滚。可见与本地事务不同的是，分布式事务需要多一次的 `PREPARE` 操作，待收到所有节点的同意信息后，再进行 `COMMIT` 或是 `ROLLBACK` 操作。

### 内部 XA 事务

在 MySQL 数据库中的存储引擎与插件之间，又或者在存储引擎与存储引擎之间的分布式事务被称为**内部 XA 事务**。

最为常见的内部 XA 事务存在于 binlog 与 InnoDB 存储引擎之间。由于复制的需要，因此目前绝大多数的数据库都开启了 binlog 功能。在事务提交时，先写二进制日志，再写 InnoDB 存储引擎的重做日志。对上述两个操作的要求也是原子的，即二进制日志和重做日志必须同时写入。若二进制日志先写了，而在写入 InnoDB 存储引擎时发生了宕机，那么 slave 可能会接收到 master 传过去的二进制日志并执行，最终导致了主从不一致的情况。如下图所示。

![宕机导致replication主从不一致的情况](imgs/%E5%AE%95%E6%9C%BA%E5%AF%BC%E8%87%B4replication%E4%B8%BB%E4%BB%8E%E4%B8%8D%E4%B8%80%E8%87%B4%E7%9A%84%E6%83%85%E5%86%B5.png)

如果执行完①、②后在步骤③之前MySQL数据库发生了宕机，则会发生主从不一致的情况。为了解决这个问题，MySQL 数据库在 binlog 与 InnoDB 存储引擎之间采用 XA 事务。当事务提交时，InnoDB 存储引擎会先做一个 PREPARE 操作，将事务的 xid 写入，接着进行二进制日志的写入，如下图所示。如果在InnoDB 存储引擎提交前，MySQL 数据库宕机了，那么 MySQL 数据库在重启后会先检查准备的 UXID 事务是否已经提交，若没有，则在存储引擎层再进行一次提交操作。

![MySQL数据库通过内部XA事务保证主从数据一致](imgs/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%80%9A%E8%BF%87%E5%86%85%E9%83%A8XA%E4%BA%8B%E5%8A%A1%E4%BF%9D%E8%AF%81%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4.png)

## 长事务

长事务(Long-Lived Transactions)，顾名思义，就是执行时间较长的事务。

长事务产生了一个问题，在执行过程中，当数据库或操作系统、硬件等发生问题时，重新开始事务的代价变得不可接受。数据库需要回滚所有已经发生的变化，而这个过程可能比产生这些变化的时间还要长。因此，对于长事务的问题，有时可以通过**转化为小批量(mini batch)的事务**来进行处理。当事务发生错误时，只需要回滚一部分数据，然后接着上次已完成的事务继续进行。

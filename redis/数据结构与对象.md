# 数据结构

参考文章: [Redis 设计与实现](http://redisbook.com/index.html)

## SDS

SDS 与 C 字符串的区别：

- 常数时间获取字符串长度
    - C 字符串并不记录自身的长度信息，获取一个 C 字符串的长度， 程序必须遍历整个字符串， 对遇到的每个字符进行计数， 直到遇到代表字符串结尾的空字符为止， 这个操作的复杂度为 O(N) 
    - SDS 在 len 属性中记录了 SDS 本身的长度， 所以获取一个 SDS 长度的复杂度仅为 O(1)
- 杜绝缓冲区溢出
    - 因为 C 字符串不记录自身的长度， 所以 strcat 假定用户在执行这个函数时， 已经为 dest 分配了足够多的内存， 可以容纳 src 字符串中的所有内容， 而一旦这个假定不成立时， 就会产生缓冲区溢出。
    - 当 SDS API 需要对 SDS 进行修改时， API 会先检查 SDS 的空间是否满足修改所需的要求， 如果不满足的话， API 会自动将 SDS 的空间扩展至执行修改所需的大小， 然后才执行实际的修改操作， 所以使用 SDS 既不需要手动修改 SDS 的空间大小， 也不会出现前面所说的缓冲区溢出问题。
- 减少修改字符串时带来的内存重分配次数
    - 因为 C 字符串的长度和底层数组的长度之间存在着这种关联性， 所以每次增长或者缩短一个 C 字符串， 程序都总要对保存这个 C 字符串的数组进行一次内存重分配操作
    - SDS 通过未使用空间解除了字符串长度和底层数组长度之间的关联： 在 SDS 中， buf 数组的长度不一定就是字符数量加一， 数组里面可以包含未使用的字节， 而这些字节的数量就由 SDS 的 free 属性记录
- 二进制安全
    - C 字符串中的字符必须符合某种编码（比如 ASCII）， 并且除了字符串的末尾之外， 字符串里面不能包含空字符， 否则最先被程序读入的空字符将被误认为是字符串结尾 —— 这些限制使得 C 字符串只能保存文本数据
    - SDS 使用 len 属性的值而不是空字符来判断字符串是否结束，可用于存放二进制数据
- 兼容部分 C 字符串函数
    - SDS 保存的数据的末尾设置为空字符， 并且总会在为 buf 数组分配空间时多分配一个字节来容纳这个空字符， 这是为了让那些保存文本数据的 SDS 可以重用一部分

## 链表

双链表

- 双端： 链表节点带有 prev 和 next 指针， 获取某个节点的前置节点和后置节点的复杂度都是 O(1) 。
- 无环： 表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL ， 对链表的访问以 NULL 为终点。
- 带表头指针和表尾指针： 通过 list 结构的 head 指针和 tail 指针， 程序获取链表的表头节点和表尾节点的复杂度为 O(1) 。
- 带链表长度计数器： 程序使用 list 结构的 len 属性来对 list 持有的链表节点进行计数， 程序获取链表中节点数量的复杂度为 O(1) 。
- 多态： 链表节点使用 void* 指针来保存节点值， 并且可以通过 list 结构的 dup 、 free 、 match 三个属性为节点值设置类型特定函数， 所以链表可以用于保存各种不同类型的值。

## 字典

Redis 的字典使用哈希表作为底层实现， 一个哈希表里面可以有多个哈希表节点， 而每个哈希表节点就保存了字典中的一个键值对。

哈希表是数组+链表的结构，哈希表使用链地址法（separate chaining）来解决键冲突。

字典的 ht 属性是一个包含两个项的数组， 数组中的每个项都是一个 dictht 哈希表， 一般情况下， 字典只使用 ht[0] 哈希表， ht[1] 哈希表只会在对 ht[0] 哈希表进行 rehash 时使用。

除了 ht[1] 之外， 另一个和 rehash 有关的属性就是 rehashidx ： 它记录了 rehash 目前的进度， 如果目前没有在进行 rehash ， 那么它的值为 -1 。

### rehash

随着操作的不断执行， 哈希表保存的键值对会逐渐地增多或者减少， 为了让哈希表的负载因子（load factor）维持在一个合理的范围之内， 当哈希表保存的键值对数量太多或者太少时， 程序需要对哈希表的大小进行相应的扩展或者收缩。

扩展和收缩哈希表的工作可以通过执行 rehash （重新散列）操作来完成， Redis 对字典的哈希表执行 rehash 的步骤如下：

1. 为字典的 ht[1] 哈希表分配空间， 这个哈希表的空间大小取决于要执行的操作， 以及 ht[0] 当前包含的键值对数量 （也即是 ht[0].used 属性的值）：
    - 如果执行的是扩展操作， 那么 ht[1] 的大小为第一个大于等于 ht[0].used * 2 的 2^n （2 的 n 次方幂）；
    - 如果执行的是收缩操作， 那么 ht[1] 的大小为第一个大于等于 ht[0].used 的 2^n 。
2. 将保存在 ht[0] 中的所有键值对 rehash 到 ht[1] 上面： rehash 指的是重新计算键的哈希值和索引值， 然后将键值对放置到 ht[1] 哈希表的指定位置上。
3. 当 ht[0] 包含的所有键值对都迁移到了 ht[1] 之后 （ht[0] 变为空表）， 释放 ht[0] ， 将 ht[1] 设置为 ht[0] ， 并在 ht[1] 新创建一个空白哈希表， 为下一次 rehash 做准备。


### 扩展与收缩

当以下条件中的任意一个被满足时， 程序会自动开始对哈希表执行扩展操作：
- 服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 1 ；
- 服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 5 ；

当哈希表的负载因子小于 0.1 时， 程序自动开始对哈希表执行收缩操作。

### 渐进式rehash

扩展或收缩哈希表需要将 ht[0] 里面的所有键值对 rehash 到 ht[1] 里面， 但是， 这个 rehash 动作并不是一次性、集中式地完成的， 而是分多次、渐进式地完成的。

哈希表渐进式 rehash 的详细步骤：

1. 为 ht[1] 分配空间， 让字典同时持有 ht[0] 和 ht[1] 两个哈希表。
2. 在字典中维持一个索引计数器变量 rehashidx ， 并将它的值设置为 0 ， 表示 rehash 工作正式开始。
3. 在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1] ， 当 rehash 工作完成之后， 程序将 rehashidx 属性的值增一。
4. 随着字典操作的不断执行， 最终在某个时间点上， ht[0] 的所有键值对都会被 rehash 至 ht[1] ， 这时程序将 rehashidx 属性的值设为 -1 ， 表示 rehash 操作已完成。

渐进式 rehash 的好处在于它采取分而治之的方式， 将 rehash 键值对所需的计算工作均滩到对字典的每个添加、删除、查找和更新操作上， 从而避免了集中式 rehash 而带来的庞大计算量。

## 跳跃表

跳跃表（跳跃表）是一种**有序**数据结构， 它通过在每个节点中维持多个指向其他节点的指针， 从而达到快速访问节点的目的。

跳跃表支持平均 O(log N) 最坏 O(N) 复杂度的节点查找， 还可以通过顺序性操作来批量处理节点。

详情参见 [Skip List--跳表（全网最详细的跳表文章没有之一）](https://www.jianshu.com/p/9d8296562806)。

### 二分查找的有序双链表

1. 有序双链表的特性就是每个元素存放下一个元素的引用。原始链表元素个数 N
2. 从链表中每两个元素抽出来，加一级索引，一级索引指向了原始链表。一级索引元素个数 N/2
3. 每四个元素加一级索引作为二级索引，二级索引指向一级索引。二级索引元素个数 N/4
4. 以此类推
5. 如果最高级索引只剩两个元素，就使得链表能够实现二分查找。最高及索引元素个数 2

索引的高度为 logN

### 查找时间复杂度

查找元素的过程是从最高级索引开始，一层一层遍历最后下沉到原始链表。

时间复杂度 = 索引的高度 * 每层索引遍历元素的个数。

索引高度为 logN

在每层索引会先判断当前索引的下一个元素是否小于目标值
- 如果等于，找到目标节点
- 如果小于，跳转到索引的下一个元素，再跳转到下一级索引元素节点，如此往复一直下沉到源链表
- 如果大于，跳转到下一级索引的元素节点，如此往复一直下沉到源链表

可见每次下沉都会至多会遍历3个节点，下沉复杂度O(1)，一共下沉logN次，所以查询时间复杂度为logN。

### 空间复杂度

原始链表包含 n 个元素，则一级索引元素个数为 n/2、二级索引元素个数为 n/4、三级索引元素个数为 n/8 以此类推。
索引节点的总和是：n/2 + n/4 + n/8 + … + 8 + 4 + 2 = n-2，空间复杂度是 O(n)。

### 插入数据

为了维护索引，随机选 n/2 个元素做为一级索引、随机选 n/4 个元素做为二级索引、随机选 n/8 个元素做为三级索引，依次类推，一直到最顶层索引。

我们可以实现一个 randomLevel() 方法，该方法会随机生成 1~MAX_LEVEL 之间的数（MAX_LEVEL表示索引的最高层数），且该方法有 1/2 的概率返回 1、1/4 的概率返回 2、1/8的概率返回 3，以此类推。

元素插入首先要查找元素，查找的时间复杂度为O(logN)。在查找的目标位置后，进行插入。randomLevel() 方法决定索引的高度，因此需要进行 randomLevel() 次插入，每次插入的时间复杂度为O(1)，最多执行logN次。因此元素插入的时间复杂度 = 查找时间复杂度O(logN) + logN * O(1) = O(logN)。

### 删除数据

删除元素的过程跟查找元素的过程类似，只不过在查找的路径上如果发现了要删除的元素 x，则执行删除操作。跳表中，每一层索引其实都是一个有序的单链表，单链表删除元素的时间复杂度为 O(1)，索引层数为 logn 表示最多需要删除 logn 个元素，所以删除元素的总时间包含 查找元素的时间 加 删除 logn个元素的时间 为 O(logn) + O(logn) = 2 O(logn)，忽略常数部分，删除元素的时间复杂度为 O(logn)。

### 跳跃表优势

跳跃表和红黑树都可以用来实现有序集合。且时间复杂度和空间复杂度相似。

为什么有序集使用跳跃表：
1. 在做范围查找的时候，平衡树比跳跃表操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在跳跃表上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。
2. 平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而跳跃表的插入和删除只需要修改相邻节点的指针，操作简单又快速。
3. 从内存占用上来说，跳跃表比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而跳跃表每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。
4. 查找单个key，跳跃表和平衡树的时间复杂度都为O(logN)，大体相当。
5. 从算法实现难度上来比较，跳跃表比平衡树要简单得多。

## 整数集合

整数集合（intset）是 Redis 用于保存整数值的集合抽象数据结构，它的底层数据结构实际上是而类型为 int_8 的整型数组。
通过 encoding  属性表示保存的整型数值的编码方式。整数集合可以保存类型为 int16_t 、int32_t 或者 int64_t 的整数值， 并且保证集合中不会出现重复元素。

### 升级

每当我们要将一个新元素添加到整数集合里面， 并且新元素的类型比整数集合现有所有元素的类型都要长时， 整数集合需要先进行升级（upgrade）， 然后才能将新元素添加到整数集合里面。

升级整数集合并添加新元素共分为三步进行：

1. 根据新元素的类型， 扩展整数集合底层数组的空间大小， 并为新元素分配空间。
2. 将底层数组现有的所有元素都转换成与新元素相同的类型， 并将类型转换后的元素放置到正确的位上， 而且在放置元素的过程中， 需要继续维持底层数组的有序性质不变。
3. 将新元素添加到底层数组里面。

### 降级

整数集合不支持降级操作， 一旦对数组进行了升级， 编码就会一直保持升级后的状态。

## 压缩列表

压缩列表是 Redis 为了**节约内存**而开发的， 由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构。本质上是一个使用**链表的数组实现**。

当一个列表键只包含少量列表项， 并且每个列表项要么就是小整数值， 要么就是长度比较短的字符串， 那么 Redis 就会使用压缩列表来做列表键的底层实现。

### 连续更新

每个节点的 previous_entry_length 属性都记录了前一个节点的长度：

- 如果前一节点的长度小于 254 字节， 那么 previous_entry_length 属性需要用 1 字节长的空间来保存这个长度值。
- 如果前一节点的长度大于等于 254 字节， 那么 previous_entry_length 属性需要用 5 字节长的空间来保存这个长度值。

于是在添加或删除元素的时候可能会导致[连续更新](http://redisbook.com/preview/ziplist/cascade_update.html)的情况发生。连续更新的时间复杂度为O(N^2)

要注意的是， 尽管连锁更新的复杂度较高， 但它真正造成性能问题的几率是很低的。平均时间复杂度仍然能够控制在O(N)。

## 对象类型与编码

Redis 使用对象来表示数据库中的键和值， 每次当我们在 Redis 的数据库中新创建一个键值对时， 我们至少会创建两个对象， 一个对象用作键值对的键（键对象）， 另一个对象用作键值对的值（值对象）。

Redis 中的每个对象都由一个 redisObject 结构表示， 该结构中和保存数据有关的三个属性分别是 type 属性、 encoding 属性和 ptr 属性。

### 类型

|类型常量|对象的名称|TYPE 命令输出|
|-------|---------|-------|
|REDIS_STRING|字符串对象|string|
|REDIS_LIST|列表对象|list|
|REDIS_HASH|哈希对象|hash|
|REDIS_SET|集合对象|set|
|REDIS_ZSET|有序集合对象|zset|


### 编码

|编码常量|编码所对应的底层数据结构|OBJECT ENCODING 命令输出|
|-------|--------------------|---------|
|REDIS_ENCODING_INT|long 类型的整数|int|
|REDIS_ENCODING_EMBSTR|embstr 编码的简单动态字符串|embstr|
|REDIS_ENCODING_RAW|简单动态字符串|raw|
|REDIS_ENCODING_HT|字典|hashtabl|
|REDIS_ENCODING_LINKEDLIST|双端链表|linkedlist|
|REDIS_ENCODING_ZIPLIST|压缩列表|ziplist|
|REDIS_ENCODING_INTSET|整数集合|intset|
|REDIS_ENCODING_SKIPLIST|跳跃表和字典|skiplist|

### 类型与编码

|类型|编码|对象|条件|
|---|----|----|-----|
|REDIS_STRING|REDIS_ENCODING_INT|使用整数值实现的字符串对象|可以用long类型表示的整数|
|REDIS_STRING|REDIS_ENCODING_EMBSTR|使用 embstr 编码的简单动态字符串实现的字符串对象|字符串长度小于等于39|
|REDIS_STRING|REDIS_ENCODING_RAW|使用简单动态字符串实现的字符串对象|字符串长度大于39|
|REDIS_LIST|REDIS_ENCODING_ZIPLIST|使用压缩列表实现的列表对象|元素长度小于64字节且元素数量小于512|
|REDIS_LIST|REDIS_ENCODING_LINKEDLIST|使用双端链表实现的列表对象|元素长度大于等于64字节或元素数量大于等于512|
|REDIS_HASH|REDIS_ENCODING_ZIPLIST|使用压缩列表实现的哈希对象|元素长度小于64字节且元素数量小于512|
|REDIS_HASH|REDIS_ENCODING_HT|使用字典实现的哈希对象|元素长度大于等于64字节或元素数量大于等于512|
|REDIS_SET|REDIS_ENCODING_INTSET|使用整数集合实现的集合对象|所有元素都是整数且元素数量不超过512|
|REDIS_SET|REDIS_ENCODING_HT|使用字典实现的集合对象|元素不都是整数或者元素数量超过512|
|REDIS_ZSET|REDIS_ENCODING_ZIPLIST|使用压缩列表实现的有序集合对象|元素长度小于64字节且元素数小于128|
|REDIS_ZSET|REDIS_ENCODING_SKIPLIST|使用跳跃表和字典实现的有序集合对象|元素长度大于等于64字节或元素数大于等于128|

值得一提的是 REDIS_ENCODING_SKIPLIST 编码同时包含一个字典和跳跃表，这样同时保证了字典的常数时间查询和跳跃表有序的特点。

### 类型检查和多态

因为Redis 对象有不同种类型，而一种命令只能针对特定的类型， 为了确保只有指定类型的键可以执行某些特定的命令， 在执行一个类型特定的命令之前， Redis 会先进行**类型检查**来判断类型是否正确， 然后再决定是否执行给定的命令。

同时一个对象类型会有多种编码方式，通过**多态**选择正确的命令实现代码来执行命令。

### 内存回收

Redis 在自己的对象系统中构建了一个引用计数（reference counting）技术实现的内存回收机制， 通过这一机制， 程序可以通过跟踪对象的引用计数信息， 在适当的时候自动释放对象并进行内存回收。

对象的引用计数信息会随着对象的使用状态而不断变化：
- 在创建一个新对象时， 引用计数的值会被初始化为 1 ；
- 当对象被一个新程序使用时， 它的引用计数值会被增一；
- 当对象不再被一个程序使用时， 它的引用计数值会被减一；
- 当对象的引用计数值变为 0 时， 对象所占用的内存会被释放。

### 对象共享

<!-- TODO -->

### 对象的空转时长

<!-- TODO -->
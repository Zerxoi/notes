# Rust基础

- 栈：LIFO，数据大小确定，效率高
  - 字符串字面量 &str 在编译期间就能确定数据大小，因此字符串字面量时在栈上分配的
- 堆：数据大小位置或者数据大小可变，效率低
  - 分配内存（allocate）：内存分配器（memory allocator）在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的 指针（pointer）。
  - 内存回收（free）：将处理完成的内存返回给分配器
- 所有权：Rust使用所有权系统管理内存。其他内存管理方式：垃圾回收，手动分配释放
- 所有者：拥有Rust值所有权的变量
- 变量作用域：一个项（item）在程序中有效的范围。
  - 变量在作用域内生效
  - 变量在离开作用域时会释放分配的内存
- 二次释放：两个数据指针指向了同一位置，都会尝试释放相同的内存
- 变量与数据交互的方式
  - 移动（move）：仅存在于堆上分配内存的变量的赋值
    - 类似于浅拷贝，不过因为 Rust 同时使第一个变量无效了，这个操作被称为 移动（move），而不是叫做浅拷贝（shallow copy）
  - 克隆（clone）：深度复制中堆上的数据，而不仅仅是栈上的数据，神拷贝（deep copy）
  - 拷贝（copy）：只在栈上的数据
    - 像整型这样的在编译时已知大小的类型被整个存储在栈上，所以拷贝其实际的值是快速的。
    - Copy trait：Rust 有一个叫做 Copy trait 的特殊注解，可以用在类似整型这样的存储在栈上的类型上。如果一个类型实现了 Copy trait，那么一个旧的变量在将其赋值给其他变量后仍然可用。
    - number、bool、float、char、copy trait tuple
- 引用（references）：
  - Rust 提供的一个不用获取所有权就可以使用值的功能，&s1 语法让我们创建一个 指向 值 s1 的引用，但是并不拥有它。因为并不拥有这个值，所以当引用停止使用时，它所指向的值也不会被丢弃
  - 引用（reference）像一个指针，因为它是一个地址，我们可以由此访问储存于该地址的属于其他变量的数据。与指针不同，引用确保指向某个特定类型的有效值
  - 引用默认是不可变的，不可变引用的用户可不希望在他们的眼皮底下值就被意外的改变了！
    - 多个不可变引用是可以的，因为没有哪个只能读取数据的人有能力影响其他人读取到的数据（多个不可变应用创建到使用过程中不能出现可变引用的创建）
  - 方法调用时会创建并获取对象的引用 例如：s.clear() 需要清空 String s，它尝试获取一个可变引用。
- 借用（borrowing）:创建一个引用的行为
- 可变引用（mutable reference）：引用默认是不可变的，可变引用允许我们修改一个借用的值
  - 如果你有一个对该变量的可变引用，你就不能再创建对该变量的引用（一个可变引用的创建到使用区间内不能创建其他可变引用）。这个限制的好处是 Rust 可以在编译时就避免数据竞争
- 数据竞争（data race）类似于竞态条件，它可由这三个行为造成：
  - 两个或更多指针同时访问同一数据。
  - 至少有一个指针被用来写入数据。
  - 没有同步数据访问的机制。
- 引用作用域重叠规则：
  - 不可变作用域是可以重叠的（S🔒）
  - 可变作用域之间不允许重叠（X🔒）
- 悬垂指针（dangling pointer）：在具有指针的语言中，很容易通过释放内存时保留指向它的指针而错误地生成一个 悬垂指针（dangling pointer），所谓悬垂指针是其指向的内存可能已经被分配给其它持有者。
  - 相比之下，在 Rust 中编译器确保引用永远也不会变成悬垂状态：当你拥有一些数据的引用，编译器确保数据不会在其引用 return 之前离开作用域。
- slice: slice 允许你引用集合中一段连续的元素序列，而不用引用整个集合。slice 是一类引用，所以它没有所有权。
- 字符串slice：类型声明写作 `&str`
  - &str参数除了可以传递字符串（字面量）slice，还可以使用字符串引用（&String），这种灵活性利用了 deref coercions 的优势
- 其他类型的 slice： 比如 `&[i32]`
- struct（structure）：一个自定义数据类型，允许你包装和命名多个相关的值，从而形成一个有意义的组合。
  - 注意整个实例必须是可变的；Rust 并不允许只将某个字段标记为可变。
  - 字段初始化简写语法（field init shorthand）
  - 结构体更新语法（struct update syntax）:使用旧实例的大部分值但改变其部分值来创建一个新的结构体实例通常是很有用的
    - 结构更新语法就像带有 = 的赋值
      - 如果更新的字段中有移动（move），源对象不可用
      - 如果更新字段全是拷贝（copy），源对象可用
  - 元组结构体（tuple structs）：元组结构体有着结构体名称提供的含义，但没有具体的字段名，只有字段的类型。
  - 类单元结构体（unit-like structs）:一个没有任何字段的结构体。类似于 ()，即“元组类型”一节中提到的 unit 类型
  - struct所有权：struct的属性可以是拥有自身所有权的类型；可以使结构体存储被其他对象拥有的数据的引用，不过这么做的话需要用上 生命周期（lifetimes）。
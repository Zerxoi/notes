# Rust基础

- 栈：LIFO，数据大小确定，效率高
  - 字符串字面量 &str 在编译期间就能确定数据大小，因此字符串字面量时在栈上分配的
- 堆：数据大小位置或者数据大小可变，效率低
  - 分配内存（allocate）：内存分配器（memory allocator）在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的 指针（pointer）。
  - 内存回收（free）：将处理完成的内存返回给分配器
- 所有权：Rust使用所有权系统管理内存。其他内存管理方式：垃圾回收，手动分配释放
- 所有者：拥有Rust值所有权的变量
- 变量作用域：一个项（item）在程序中有效的范围。
  - 变量在作用域内生效
  - 变量在离开作用域时会释放分配的内存
- 二次释放：两个数据指针指向了同一位置，都会尝试释放相同的内存
- 变量与数据交互的方式
  - 移动（move）：仅存在于堆上分配内存的变量的赋值
    - 类似于浅拷贝，不过因为 Rust 同时使第一个变量无效了，这个操作被称为 移动（move），而不是叫做浅拷贝（shallow copy）
  - 克隆（clone）：深度复制中堆上的数据，而不仅仅是栈上的数据，神拷贝（deep copy）
  - 拷贝（copy）：只在栈上的数据
    - 像整型这样的在编译时已知大小的类型被整个存储在栈上，所以拷贝其实际的值是快速的。
    - Copy trait：Rust 有一个叫做 Copy trait 的特殊注解，可以用在类似整型这样的存储在栈上的类型上。如果一个类型实现了 Copy trait，那么一个旧的变量在将其赋值给其他变量后仍然可用。
    - number、bool、float、char、copy trait tuple
- 引用（references）：
  - Rust 提供的一个不用获取所有权就可以使用值的功能，&s1 语法让我们创建一个 指向 值 s1 的引用，但是并不拥有它。因为并不拥有这个值，所以当引用停止使用时，它所指向的值也不会被丢弃
  - 引用（reference）像一个指针，因为它是一个地址，我们可以由此访问储存于该地址的属于其他变量的数据。与指针不同，引用确保指向某个特定类型的有效值
  - 引用默认是不可变的，不可变引用的用户可不希望在他们的眼皮底下值就被意外的改变了！
    - 多个不可变引用是可以的，因为没有哪个只能读取数据的人有能力影响其他人读取到的数据（多个不可变应用创建到使用过程中不能出现可变引用的创建）
  - 方法调用时会创建并获取对象的引用 例如：s.clear() 需要清空 String s，它尝试获取一个可变引用。
    - Rust 并没有一个与 -> 等效的运算符；相反，Rust 有一个叫 自动引用和解引用（automatic referencing and dereferencing）的功能。方法调用是 Rust 中少数几个拥有这种行为的地方。
    - 它是这样工作的：当使用 object.something() 调用方法时，Rust 会自动为 object 添加 &、&mut 或 * 以便使 object 与方法签名匹配。
- 借用（borrowing）:创建一个引用的行为
- 可变引用（mutable reference）：引用默认是不可变的，可变引用允许我们修改一个借用的值
  - 如果你有一个对该变量的可变引用，你就不能再创建对该变量的引用（一个可变引用的创建到使用区间内不能创建其他可变引用）。这个限制的好处是 Rust 可以在编译时就避免数据竞争
- 数据竞争（data race）类似于竞态条件，它可由这三个行为造成：
  - 两个或更多指针同时访问同一数据。
  - 至少有一个指针被用来写入数据。
  - 没有同步数据访问的机制。
- 引用作用域重叠规则：
  - 不可变作用域是可以重叠的（S🔒）
  - 可变作用域之间不允许重叠（X🔒）
- 悬垂指针（dangling pointer）：在具有指针的语言中，很容易通过释放内存时保留指向它的指针而错误地生成一个 悬垂指针（dangling pointer），所谓悬垂指针是其指向的内存可能已经被分配给其它持有者。
  - 相比之下，在 Rust 中编译器确保引用永远也不会变成悬垂状态：当你拥有一些数据的引用，编译器确保数据不会在其引用 return 之前离开作用域。
- slice: slice 允许你引用集合中一段连续的元素序列，而不用引用整个集合。slice 是一类引用，所以它没有所有权。
- 字符串slice：类型声明写作 `&str`
  - &str参数除了可以传递字符串（字面量）slice，还可以使用字符串引用（&String），这种灵活性利用了 deref coercions 的优势
- 其他类型的 slice： 比如 `&[i32]`
- struct（structure）：一个自定义数据类型，允许你包装和命名多个相关的值，从而形成一个有意义的组合。
  - 注意整个实例必须是可变的；Rust 并不允许只将某个字段标记为可变。
  - 字段初始化简写语法（field init shorthand）
  - 结构体更新语法（struct update syntax）:使用旧实例的大部分值但改变其部分值来创建一个新的结构体实例通常是很有用的
    - 结构更新语法就像带有 = 的赋值
      - 如果更新的字段中有移动（move），源对象不可用
      - 如果更新字段全是拷贝（copy），源对象可用
  - 元组结构体（tuple structs）：元组结构体有着结构体名称提供的含义，但没有具体的字段名，只有字段的类型。
  - 类单元结构体（unit-like structs）:一个没有任何字段的结构体。类似于 ()，即“元组类型”一节中提到的 unit 类型
  - struct所有权：struct的属性可以是拥有自身所有权的类型；可以使结构体存储被其他对象拥有的数据的引用，不过这么做的话需要用上 生命周期（lifetimes）。
  - 关联函数：所有在 impl 块中定义的函数
    - 方法：定义的以 self 为第一参数的关联函数
      - 使用 &self 来替代 rectangle: &Rectangle，&self 实际上是 self: &Self 的缩写。在一个 impl 块中，Self 类型是 impl 块的类型的别名。方法的第一个参数必须有一个名为 self 的Self 类型的参数，所以 Rust 让你在第一个参数位置上只用 self 这个名字来缩写。
      - 方法可以选择获得 self 的所有权，或者像我们这里一样不可变地借用 self，或者可变地借用 self，就跟其他参数一样。
    - 不是方法的关联函数经常被用作返回一个结构体新实例的构造函数，使用结构体名和 :: 语法来调用这种关联函数
- 枚举（enumerations，enums）：枚举允许你通过列举可能的 成员（variants）来定义一个类型。
  - 举的成员位于其标识符的命名空间中，并使用两个冒号分开，eg IpAddrKind::V4
  - 员组成员可以使用结构体的所有写法：类单元结构体，元组结构体等等
  - 可以使用impl来为枚举定义方法
  - Option:Rust 并没有空值，不过它确实拥有一个可以编码存在或不存在概念的枚举 —— `Option<T>`
    - `Option<T>` 枚举是如此有用以至于它甚至被包含在了 prelude 之中，你不需要将其显式引入作用域
    - 为什么 `Option<T>` 比空值要好呢？简而言之，因为 `Option<T>` 和 `T`（这里 `T` 可以是任何类型）是不同的类型，编译器不允许像一个肯定有效的值那样使用 `Option<T>`。
  - match 控制流：Rust 有一个叫做 match 的极为强大的控制流运算符，它允许我们将一个值与一系列的模式相比较，并根据相匹配的模式执行相应代码。
    - 模式可由字面值、变量、通配符和许多其他内容构成。
    - Rust 中的匹配是 穷尽的（exhaustive）：必须穷举到最后的可能性来使代码有效。
      - 通配模式：最后一个模式将匹配所有未被特殊列出的值。这种通配模式满足了 match 必须被穷尽的要求。请注意，我们必须将通配分支放在最后，因为模式是按顺序匹配的。
      - `_`: Rust 还提供了一个模式，当我们不想使用通配模式获取的值时，请使用 _ ，这是一个特殊的模式，可以匹配任意值而不绑定到该值。这告诉 Rust 我们不会使用这个值，所以 Rust 也不会警告我们存在未使用的变量。
  - if let 语法获取通过等号分隔的一个模式和一个表达式。它的工作方式与 match 相同，这里的表达式对应 match 而模式则对应第一个分支。
    - 使用 if let 意味着编写更少代码，更少的缩进和更少的样板代码。然而，这样会失去 match 强制要求的穷尽性检查。match 和 if let 之间的选择依赖特定的环境以及增加简洁度和失去穷尽性检查的权衡取舍。换句话说，可以认为 if let 是 match 的一个语法糖，它当值匹配某一模式时执行代码而忽略所有其他值。


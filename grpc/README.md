# gRPC

## Protocol Buffers

参考：[What are protocol buffers?](https://developers.google.com/protocol-buffers/docs/overview)

Protocol Buffers提供了一种语言中立、平台中立、可扩展的机制，以向前兼容和向后兼容的方式序列化结构化数据。它就像JSON，只是它更小、更快，而且能生成本地语言绑定。

Protocol Buffers是**定义语言**（在`.proto`文件中创建）、**proto编译器生成的与数据交互的代码**、**特定语言的运行库**以及**写入文件（或通过网络连接发送）的数据的序列化格式**的组合。

### 解决问题

Protocol Buffers为大小高达几兆字节的类型化结构化数据包提供了一种序列化格式。该格式适用于**临时网络流量**和**长期数据存储**。可以使用新信息扩展Protocol Buffers，而无需使现有数据无效或需要更新代码。

Protocol Buffers是 Google 最常用的数据格式。它们广泛用于**服务器间通信**以及**磁盘上数据的归档存储**。Protocol Buffers消息和服务由工程师编写的 `.proto` 文件描述。下面显示了一个示例 `message`：

```proto
message Person {
  optional string name = 1;
  optional int32 id = 2;
  optional string email = 3;
}
```

proto编译器在`.proto`文件的构建时被调用，以生成各种编程语言的代码来操作相应的Protocol Buffers。每个生成的类都包含每个字段的简单访问器和方法，用于**序列化**和**解析**整个结构与原始字节之间的关系。下面向您展示了一个使用这些生成方法的示例：

```java
Person john = Person.newBuilder()
    .setId(1234)
    .setName("John Doe")
    .setEmail("jdoe@example.com")
    .build();
output = new FileOutputStream(args[0]);
john.writeTo(output);
```

由于Protocol Buffers在 Google 的各种服务中广泛使用，并且其中的数据可能会保留一段时间，因此保持**向后兼容性**至关重要；**向前兼容**：*Protocol Buffers允许无缝支持对任何Protocol Buffers的更改，包括添加新字段和删除现有字段，而不会破坏现有服务*。

### 优点

Protocol Buffers非常适合任何需要以**语言中立**、**平台中立**、**可扩展**的方式序列化*结构化*、*类似记录*、*类型化*数据的情况。它们最常用于定义**通信协议**（与 gRPC 一起）和**数据存储**。

使用Protocol Buffers的一些优点包括：
- 紧凑的数据存储
- 快速解析
- 许多编程语言的可用性
- 通过自动生成的类来优化功能

#### 语言中立

*以任何受支持的编程语言编写的代码都可以读取相同的消息*。您可以让一个平台上的 Java 程序从一个软件系统捕获数据，根据 .proto 定义对其进行序列化，然后在另一个平台上运行的单独 Python 应用程序中从序列化数据中提取特定值。

#### 跨项目支持

您可以通过在驻留在特定项目代码库之外的 .proto 文件中定义消息类型来跨项目使用Protocol Buffers。如果您正在定义您预计将在您的直接团队之外广泛使用的消息类型或枚举，您可以将它们放在自己的文件中，而无需依赖。

#### 在不更新代码的情况下更新 proto 定义

软件产品向后兼容是标准，但向前兼容却不太常见。只要您在更新 .proto 定义时遵循一些[简单的做法](https://developers.google.com/protocol-buffers/docs/proto#updating)，旧代码将毫无问题地读取新消息，而忽略任何新添加的字段。对于旧代码，删除的字段将具有默认值，删除的重复字段将为空。

新代码也将透明地读取旧消息。旧消息中不会出现新字段；在这些情况下，Protocol Buffers提供了一个合理的默认值。

#### Protocol Buffers 工作流程

![Protocol Buffers工作流](imgs/protocol%20buffers%20workflow.png)

#### Protocol Buffers定义语法

定义 .proto 文件时，您可以指定字段是**可选的**或**重复的**（proto2 和 proto3）或**单数**（proto3）。

设置字段的可选性/可重复性后，指定**数据类型**。Protocol Buffers支持通常的原始数据类型，例如整数、布尔值和浮点数。有关完整列表，请参阅[标量值类型](https://developers.google.com/protocol-buffers/docs/proto#scalar)。

一个字段也可以是：
- 一种消息类型，以便您可以嵌套部分定义，例如用于重复数据集。
- 枚举类型，因此您可以指定一组值以供选择。
- oneof 类型，当消息有多个可选字段且最多同时设置一个字段时，可以使用该类型。
- 一种映射类型，用于将键值对添加到您的定义中。

在设置可选性和字段类型后，您分配一个**字段编号**。字段编号不能改变用途或重复使用。如果您删除一个字段，您应该保留其字段编号，以防止有人意外重复使用该编号。

#### 额外的数据类型支持

Protocol Buffers支持许多标量值类型，包括使用可变长度编码和固定大小的整数。您还可以通过定义消息来创建自己的复合数据类型，这些消息本身就是可以分配给字段的数据类型。除了简单和复合值类型之外，还发布了几种[常见类型](https://developers.google.com/protocol-buffers/docs/overview#common-types)。

## gRPC介绍

参考：[What is gRPC?](https://grpc.io/docs/what-is-grpc/)

在 gRPC 中，客户端应用程序可以直接调用不同机器上的服务器应用程序上的方法，就像它是本地对象一样，使您更容易创建分布式应用程序和服务。

- **服务定义**：与许多 RPC 系统一样，gRPC 基于定义服务的思想，指定可以远程调用的方法及其参数和返回类型。
- **服务端**：服务端实现定义的接口并运行一个 gRPC 服务器来处理客户端调用。
- **客户端**：客户端有两个存根stub，它提供与服务器相同的方法。
    - 阻塞/同步存根：这意味着 RPC 调用等待服务器响应，并且将返回响应或引发异常。 
    - 非阻塞/异步存根：对服务器进行非阻塞调用，其中异步返回响应。您只能使用异步存根进行某些类型的流式调用。

![gRPC](imgs/grpc.svg)

gRPC客户端和服务器可以在各种环境中运行并相互通信，并且可以用任何gRPC支持的语言编写。因此，例如，您可以使用 Go、Python 或 Ruby 中的客户端轻松地在 Java 中创建 gRPC 服务器。

默认情况下，gRPC 使用 Protocol Buffers，这是 Google 用于序列化结构化数据的成熟开源机制。

### 核心概念

#### 服务

与许多 RPC 系统一样，gRPC 基于定义服务的思想，指定可以远程调用的方法及其参数和返回类型。默认情况下，gRPC 使用Protocol Buffers作为接口定义语言 (IDL) 来描述服务接口和有效负载消息的结构。如果需要，可以使用其他替代方案。

gRPC 允许您定义四种服务方法：

- **Unary RPC**，其中客户端向服务器发送单个请求并获得单个响应，就像正常的函数调用一样。

```
rpc SayHello(HelloRequest) returns (HelloResponse);
```

- **Server streaming RPC**，其中客户端向服务器发送请求并获取流以读回一系列消息。客户端从返回的流中读取，直到没有更多消息为止。 gRPC 保证单个 RPC 调用中的消息顺序。

```
rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse);
```

- **Client streaming RPC**，其中客户端写入一系列消息并将它们发送到服务器，再次使用提供的流。一旦客户端完成了消息的写入，它就会等待服务器读取它们并返回它的响应。 gRPC 再次保证了单个 RPC 调用中的消息顺序。

```
rpc LotsOfGreetings(stream HelloRequest) returns (HelloResponse);
```

- **Bidirectional streaming RPC**，双方使用读写流发送一系列消息。这两个流独立运行，因此客户端和服务器可以按照他们喜欢的任何顺序读取和写入：例如，服务器可以在写入响应之前等待接收所有客户端消息，或者它可以交替读取消息然后写入消息，或其他一些读取和写入的组合。保留每个流中消息的顺序。

```
rpc BidiHello(stream HelloRequest) returns (stream HelloResponse);
```

#### API

从.proto文件中的服务定义开始，gRPC提供Protocol Buffers编译器插件，生成客户端和服务器端的代码。gRPC用户通常在客户端调用这些API，并在服务器端实现相应的API。

- 在服务端，服务端实现服务声明的方法，并运行一个 gRPC 服务器来处理客户端调用。 gRPC 基础架构解码传入请求、执行服务方法并编码服务响应。
- 在客户端，客户端有一个称为存根的本地对象，它实现与服务相同的方法。然后客户端可以在本地对象上调用这些方法，将调用的参数包装在适当的Protocol Buffers消息类型中——gRPC负责将请求发送到服务器并返回服务器的Protocol Buffers响应。

#### 同步 vs. 异步

同步的RPC调用会阻塞，直到服务器的响应到来，这是最接近RPC所期望的过程调用的抽象的方式。另一方面，网络本身就是异步的，在许多情况下，能够在不阻塞当前线程的情况下启动RPC是非常有用的。大多数语言中的 gRPC 编程 API 有同步和异步两种风格。

#### RPC生命周期

- Unary RPC

    首先考虑最简单的 RPC 类型，其中客户端发送单个请求并返回单个响应。

        1. 一旦客户端调用了一个存根方法，服务器就会被通知RPC已经被调用，并附上客户端此次调用的元数据、方法名称以及指定的截止日期（如果适用）。
        2. 然后，服务器可以立即发回自己的初始元数据（必须在任何响应之前发送），或者等待客户端的请求消息。首先发生的是特定于应用程序的。
        3. 一旦服务器收到客户端的请求消息，它就会执行任何必要的工作来创建和填充响应。然后将响应连同状态详细信息（状态代码和可选状态消息）和可选尾随元数据一起返回（如果成功）给客户端。
        4. 如果响应状态为 OK，则客户端得到响应，从而完成客户端的调用。

- Server streaming RPC

    服务器流式 RPC 类似于一元 RPC，除了服务器返回消息流以响应客户端的请求。发送所有消息后，服务器的状态详细信息（状态代码和可选状态消息）和可选的尾随元数据将发送到客户端。这样就完成了服务器端的处理。客户端在拥有所有服务器消息后完成。
- Client streaming RPC 

    客户端流式 RPC 类似于一元 RPC，不同之处在于客户端向服务器发送消息流而不是单个消息。服务器响应一条消息（连同其状态详细信息和可选的尾随元数据），通常但不一定是在它收到所有客户端的消息之后。
- Bidirectional streaming RPC

    在一个双向的流式RPC中，调用是由客户端调用方法和服务器接收客户端元数据、方法名称和最后期限发起的。服务器可以选择发回它的初始元数据或等待客户端开始流媒体消息。

    客户端和服务器端流处理是特定于应用程序的。由于这两个流是独立的，客户端和服务器可以以任意顺序读写消息。例如，服务器可以等到它收到客户端的所有消息后再写入它的消息，或者服务器和客户端可以玩“乒乓”——服务器收到请求，然后发回响应，然后客户端发送基于响应的另一个请求，依此类推。
- RPC 终止

    在gRPC中，客户端和服务器都对调用的成功做出了独立的、局部的判断，而且他们的结论可能不一致。这意味着，例如，你可能有一个RPC在服务器端成功完成（"我已经发送了所有的响应！"），但在客户端却失败了（"响应在我的最后期限之后到达！"）。服务器也有可能在客户端发送完所有请求之前就决定完成。

- RPC 取消

    客户端或服务器都可以随时取消 RPC。取消会立即终止 RPC，以便不再进行任何工作。

- 元数据

    元数据是关于特定RPC调用的信息（比如认证细节），其形式是键值对列表，其中键是字符串，值通常是字符串，但也可以是二进制数据。元数据对gRPC本身是不透明的--它让客户端向服务器提供与调用有关的信息，反之亦然。

    对元数据的访问取决于语言。
- 通道

    gRPC 通道提供与指定主机和端口上的 gRPC 服务器的连接。它在创建客户端存根时使用。客户端可以指定通道参数来修改 gRPC 的默认行为，例如打开或关闭消息压缩。通道具有状态，包括已连接和空闲。

    gRPC 如何处理关闭通道取决于语言。一些语言还允许查询通道状态。


## gRPC实践

参考：[Basics tutorial](https://grpc.io/docs/languages/java/basics/)